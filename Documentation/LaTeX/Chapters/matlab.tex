\chapter{MATLAB}

\section{Install}
\section{User}
\section{Maintainer}

\subsection{Basic concepts}
Parameters for the simulation are stored and passed as arguments to functions as objects of the class \textit{Qdot}, further refered to as QDO. The class provides properties for all parameters neccessarry for the simulation, as well as properties for administrative purposes, such as the specific simulation folder. Parameters relating to the geometry are stored in an object of subclass \textit{Geometry}. Since more than one material is possible, the geometry property is often an array of objects of class Geometry. 
To instantiate a QDO, one can call the constructor with no arguments, which will create an empty QDO. Alternatively, a string with the material name can be passed as an argument, in which case the new QDO object will be constructed based on parameters defined in an external file, located in the folder \textit{Classes}.
The class Qdot provides some methods for basic displaying of some selected parameters, such as \textit{getSelParams}.\\

%\begin{EXAMPLE}  
Creating a Qdot object based on default parameters and setting the radius to 4\\
myQdot = Qdot('CdS\_CdSe');\\
myQdot.geometry(2).radius = 4;\\
%\end{EXAMPLE}




\subsection{GUI}
\subsection{Simulation}

The simulation parameters from the GUI are passed to the functions which will then start the simulation with OMEN.
The parameters are stored in QDOs. Since it is often desirable to simulate over a range of parameters, some parameters (i.e. the radii and e-field) are at this stage not scalars, but a vectors, containing starting value, end value and number of steps in between. Such a generic QDO,  is further refered to as QDOG.
\\\\
The QDOG is passed to the function \textit{simAll.m}, which will simulate all desired parameter combinations, by performing the following steps:
\begin{itemize}
\item An array of QDOs (QDOA) with all combinations of the parameter is created in the function \textit{sweep.m} from QDOG. Supported sweep parameters are radius and electric field. This could easily be extended to other parameters by modifying the function \textit{sweep.m}.
\item The elements in the QDOA are then simulated one after the other, and all data saved in seperate folders, called ID\textit{timestamp\_material}: 
\item The OMEN command-file \textit{qdot\_cmd} is written, using the function \textit{writeCmdFile.m}.
\item The OMEN simulation will be started using the MATLAB function \textit{unix}, which calls the operating system to execute the specified command.
\item A logfile is written, recording the duration and the success of the simulation as well as the console output of OMEN. The success of the simulation is checked by inspecting whether the desired files were created.
\end{itemize}

After the simulation of all elements in the QDOA, an additional logfile is written, and saved in the folder \textit{log}. It gives information about the success of all simulations, and thus provides an easy way to check if and which simulations failed.
\\\\
Returned to the calling function is the QDOA as well as a vector indicating the success of every simulation.
\\\\
Note that it is not strictly necessary to start the simulations using the GUI. The QDOG containing the desired parameters can also be created with standard MATLAB syntax, and passed subsequently to the function \textit{simAll.m}, as is shown in the following example.\\
\\
%\begin{EXAMPLE} 
myQdot = Qdot('PbS\_lent');  creating a Qdot object with default parameters \\
myQdot.geometry.radius = [1.5 3 4]; changing the parameter radius\\
simAll(myQdot);  4 simulations with radii 1.5, 2, 2.5, 3 will be performed\\
%\end{EXAMPLE}



\subsection{Database}

In order to know which parameter sets already have been simulated, there are some useful tools, which can be found in the folder \textit{Functions/
QdotUtils}. The basic principle is to get all all parameters which were simulated, which can then be displayed in the GUI, filtered, deleted and so on.

\subsubsection{Getting the parameters from all simulations}
This is done by loading the QDOs of all performed simulations from their folders, and storing them in a QDOA. \\\\
function \textit{getQDOA}()

\subsubsection{Filtering}
function \textit{filtered = filterQDOA( QDOA, propertyName, value, mode, tol )}\\\\
The filtering can be applied to any QDOA, and returns a subset of this array, matching specified criteria. The argument \textit{propertyName} specifies the \textit{Qdot} property which is compared to \textit{value}. The filter criteria are specified by selecting a mode of filtering. 
The following filtering modes are available:\\
\begin{itemize}
\item the property exactly matches \textit{value}.
\item the property lies within a range of values, specified by a vector: \textit{value = [min max]}
\item the property approximately matches \textit{value}. For numeric properties this is specified using a tolerance \textit{tol}. For string properties the \textit{value} should be a substring of the property.
\item filter for a constant difference between two properties. The property names are specified in a cell array: \textit{propertyName = \{propertyName1, propertyName2\}}
\item filter for a constant ratio between two properties.
\end{itemize}
The last two modes are especially interesting for selecting QDOs with two or more materials, to find the objects with a specified shell-thickness.\\
\\
%\begin{EXAMPLE}
myQDOA = getQDOA;\\
\%filter for radius = 3.5 \\
filtered = filterQDOA( QDOA, 'geometry(1).radius',  3.5, 1, 0);\\
\%filter for constant difference of 0.7nm between radius of material 1 and radius of material 2, within a tolerance of +/- 10\%\\
filtered = filterQDOA( QDOA, \{'geometry(1).radius', 'geometry(2).radius'\}, 0.7, 4, 0.1 );\\
\%filter for material containing Pb:\\
filteres = filterQDOA( QDOA, 'mat\_name', 'Pb', 2, 0);\\
%\end{EXAMPLE}

\subsection{Plotting}

Here follows a short description of functions which can be used for basic visualisation of the data obtained by the OMEN simulation. For a more detailed description, please refer to the code.

\textit{Note:}
These functions are based on the directory structure created by the simulation function \textit{simAll.m}, i.e. to work properly, the simulation data, as well as the corresponding QDO must be located in their own folder, with the folder name specified in Qdot.path property.

\subsubsection{Plotting the eigenenergies}
\subsubsection{Plotting the wavefunction}

These functions all take an array of \textit{Qdot} objects (QDOA) as an input. Additionally, the number of eigenmodes to be displayed has to be specified, as well as the band (conduction or valence band). The visualisation will then be done for every one these objects, and for all specified eigenmodes.
\\\\
function \textit{\textbf{plotEV3D}( QDOA, band, NMod )} \\
Plot the atoms of the quantum dot, their color indicating the probability density of an electron or hole. Red corresponds to high, blue to low probability.
\\\\
function \textit{\textbf{plotEV3DcrossSection}( QDOA, NMod ) }\\
This function produces similar plots to the above, but it plots two cross sections of the quantum dot, for valence and conduction band respectively, in one window.
\\\\
function \textit{\textbf{plotEV3Dmax}( QDOA, band, probLim, NMod )}: \\
Again very similar to the \textit{plotEV3D}, but the color code is simplified. The atoms with very high probability densities are red, the ones with high probability yellow, the rest transparent. The color is determined in the following way: The sum of the probabilities of all red atoms is smaller than a probability value specified in \textit{probLim}. An analogous argument is applied for the yellow marked atoms.\\
This function makes it a lot easier to see how the wavefunction roughly looks like and changes from one mode to the next. 
\\\\
function \textit{\textbf{plotEVAlongAxis}( QDOA, propertyName, startPoint, direction, plotGrid, tolerance, NMod, band )}\\
Plot the probability density along an arbitrary axis through the crystal. The data for all elements of QDOA is plotted in the same plot, thus making it easier to compare quantum dots with different parameters. The axis is specified through \textit{startPoint} and \textit{direction}, including a tolerance, which is the maximum distance which an atom can deviate from the specified line. Depending on the direction, the tolerance has to be adjusted to include a sufficient number of atoms. To check this, it is useful to specify the input argument gridPlot, which will plot the atoms, the chosen axis, and highlight the atoms on the line in red. However, this function is probably only suitable for large quantum dots. Furthermore an averaging over neighbouring atoms would be recommendable.
\\\\
function \textit{\textbf{compareEV}( QDOA, band, NMod, tol, propertyName, showGrid)}: plots the same as \textit{plotEVAlongAxis}, but for three different directions (x,y,z axis), and arranges them in subplots in one figure.













